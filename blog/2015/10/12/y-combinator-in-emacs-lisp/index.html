<!DOCTYPE html>
<html lang="en-us">
  <head>
    <title>Y Combinator in Emacs Lisp - Diego Berrocal</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="author" content="Diego Berrocal">
    <meta name="description" content="Or how to implement the YCombinator in Emacs Lisp">
    <meta name="keywords" content="ycombinator, lambda, emacs, elisp">
    <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Fira+Sans:400,700,400italic,700italic|Lora:400,700|Source+Code+Pro:400,700">
    <link rel="stylesheet" href="/media/css/normalize.css">
    <link rel="stylesheet" href="/media/css/dark.css" id="darkTheme">
    <link rel="stylesheet" href="/media/css/light.css" id="lightTheme">
    <link href="http://cestdiego.github.io/atom.xml" type="application/atom+xml" rel="alternate" title="Diego Berrocal" />
    <script>
     var lightTheme = document.querySelector("#lightTheme");
     var darkTheme = document.querySelector("#darkTheme");

     var toggleTheme = function () {
         var isDefaultDisabled = lightTheme.disabled;
         darkTheme.disabled = isDefaultDisabled;
         lightTheme.disabled = !isDefaultDisabled;

         var switchLights = document.querySelector(".switch-lights");
         switchLights.textContent = "lights " + (isDefaultDisabled ? "off" : "on");

         return !isDefaultDisabled;
     };

     if (localStorage.darkTheme === "1") {
         toggleTheme();
     }
    </script>
    <link rel="stylesheet" href="/media/css/main.css">
    <noscript>
        <style>
         .toggle-colors{
             display: none;
         }
        </style>
    </noscript>
  </head>

  <body>
    <div id="wrapper">
    <nav class="site-nav">
      <ul class="links">
        <li><a href="/">Diego Berrocal</a></li>
         <li><a href="/about/">about</a></li>
        <li><a href="/blog/">blog</a></li>
        <li><a href="/atom.xml">atom</a></li>
        <li><button class="switch-lights">lights off</button></li>
      </ul>
    </nav>

    <article class="post">
      <header>
          <h1 class="post-title">Y Combinator in Emacs Lisp</h1>
          <time class="post-date">Oct 12, 2015</time>
      </header>
      <p>
I talked today with Prabhakar Ragde, who is a resident at the Recurse Center
until Oct15, and I was enlightened by lambda calculus as we figured out how to
deduce the Y Combinator that is used a lot to make recursive functions.
</p>

<p>
Here I plan to post the implementation and derivation of the Y Combinator in
Emacs Lisp.
</p>

<p>
We'll take factorial as it's good example of a recursive function
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp"><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">defun</span> <span class="org-function-name">factorial</span> <span class="org-rainbow-delimiters-depth-2">(</span>number<span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-3">(</span>eq number <span class="org-highlight-numbers-number">0</span><span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-highlight-numbers-number">1</span>
    <span class="org-rainbow-delimiters-depth-3">(</span>* number <span class="org-rainbow-delimiters-depth-4">(</span>funcall #'factorial <span class="org-rainbow-delimiters-depth-5">(</span>1- number<span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-rainbow-delimiters-depth-1">(</span>factorial <span class="org-highlight-numbers-number">5</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">120</span>
<span class="org-rainbow-delimiters-depth-1">(</span>factorial <span class="org-highlight-numbers-number">4</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">24</span>
</pre>
</div>

<pre class="example">
24
</pre>

<p>
The recursion looks trivial right? Now lets try to implement it without
referencing the name of the function, should be easy as well right?
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp"><span class="org-comment-delimiter">;; </span><span class="org-comment">factorial</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">lambda</span> <span class="org-rainbow-delimiters-depth-2">(</span>number<span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-3">(</span>eq number <span class="org-highlight-numbers-number">0</span><span class="org-rainbow-delimiters-depth-3">)</span>
      <span class="org-highlight-numbers-number">1</span>
    <span class="org-rainbow-delimiters-depth-3">(</span>* number <span class="org-rainbow-delimiters-depth-4">(</span>funcall fact? <span class="org-rainbow-delimiters-depth-5">(</span>1- number<span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>


<p>
We find that we cannot reference back to the same lambda function as we don't
have a name for it, that's why we use <code>fact?</code> we'll have to figure out what to
put in there. Lets say that we have another function that looks like factorial.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp"><span class="org-comment-delimiter">;; </span><span class="org-comment">proto-factorial</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">lambda</span> <span class="org-rainbow-delimiters-depth-2">(</span>fun number<span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-3">(</span>eq number <span class="org-highlight-numbers-number">0</span><span class="org-rainbow-delimiters-depth-3">)</span>
      <span class="org-highlight-numbers-number">1</span>
    <span class="org-rainbow-delimiters-depth-3">(</span>* number <span class="org-rainbow-delimiters-depth-4">(</span>funcall #'fun <span class="org-rainbow-delimiters-depth-5">(</span>1- number<span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
This is great! now we have a function that can take another function and that
looks like factorial doesn't it? Only one little detail though, the function
that proto-factorial accepts only takes a number, so we could say that.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp"><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">let</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-rainbow-delimiters-depth-3">(</span>proto-factorial <span class="org-rainbow-delimiters-depth-4">(</span><span class="org-keyword">lambda</span> <span class="org-rainbow-delimiters-depth-5">(</span>fun number<span class="org-rainbow-delimiters-depth-5">)</span>
                                 <span class="org-rainbow-delimiters-depth-5">(</span><span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-6">(</span>eq number <span class="org-highlight-numbers-number">0</span><span class="org-rainbow-delimiters-depth-6">)</span>
                                     <span class="org-highlight-numbers-number">1</span>
                                   <span class="org-rainbow-delimiters-depth-6">(</span>* number <span class="org-rainbow-delimiters-depth-7">(</span>funcall fun <span class="org-rainbow-delimiters-depth-8">(</span>1- number<span class="org-rainbow-delimiters-depth-8">)</span><span class="org-rainbow-delimiters-depth-7">)</span><span class="org-rainbow-delimiters-depth-6">)</span><span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-2">(</span>eq <span class="org-rainbow-delimiters-depth-3">(</span>funcall 'factorial <span class="org-highlight-numbers-number">4</span><span class="org-rainbow-delimiters-depth-3">)</span>
      <span class="org-rainbow-delimiters-depth-3">(</span>funcall proto-factorial 'factorial <span class="org-highlight-numbers-number">4</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<pre class="example">
t
</pre>

<p>
This holds true but it's not what we want. We need to not use factorial at all,
let's see if using <code>proto-factorial</code> on itself might work
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp"><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">let</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-rainbow-delimiters-depth-3">(</span>proto-factorial <span class="org-rainbow-delimiters-depth-4">(</span><span class="org-keyword">lambda</span> <span class="org-rainbow-delimiters-depth-5">(</span>fun number<span class="org-rainbow-delimiters-depth-5">)</span>
                                 <span class="org-rainbow-delimiters-depth-5">(</span><span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-6">(</span>eq number <span class="org-highlight-numbers-number">0</span><span class="org-rainbow-delimiters-depth-6">)</span>
                                     <span class="org-highlight-numbers-number">1</span>
                                   <span class="org-rainbow-delimiters-depth-6">(</span>* number <span class="org-rainbow-delimiters-depth-7">(</span>funcall fun <span class="org-rainbow-delimiters-depth-8">(</span>1- number<span class="org-rainbow-delimiters-depth-8">)</span><span class="org-rainbow-delimiters-depth-7">)</span><span class="org-rainbow-delimiters-depth-6">)</span><span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-2">(</span>funcall proto-factorial proto-factorial<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
<code>Error:eieio-oref: Wrong number of arguments: (lambda (fun number) ...), 1</code>
</p>

<p>
It didn't T_T. What this tells us is that we have not provided enough arguments,
and that's true, because proto-factorial, the function we send takes a function
and a number, and the inner call just takes another number but no function. this
is tricky, but we can have a way of doing it, let's call the function on itself
as an argument before passing another number!
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp"><span class="org-comment-delimiter">;; </span><span class="org-comment">meta-factorial</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">lambda</span> <span class="org-rainbow-delimiters-depth-2">(</span>fun number<span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-3">(</span>eq number <span class="org-highlight-numbers-number">0</span><span class="org-rainbow-delimiters-depth-3">)</span>
      <span class="org-highlight-numbers-number">1</span>
    <span class="org-rainbow-delimiters-depth-3">(</span>* number <span class="org-rainbow-delimiters-depth-4">(</span>funcall fun fun <span class="org-rainbow-delimiters-depth-5">(</span>1- number<span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
This looks more promising! meta-factorial takes a function and returns the
function evaluated with itself, this way we got what we wanted, a recursive
function!. But still looks ugly, lets arrange it in a better way
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp"><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">let</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-rainbow-delimiters-depth-3">(</span>meta-factorial <span class="org-rainbow-delimiters-depth-4">(</span><span class="org-keyword">lambda</span> <span class="org-rainbow-delimiters-depth-5">(</span>fun number<span class="org-rainbow-delimiters-depth-5">)</span>
                        <span class="org-rainbow-delimiters-depth-5">(</span><span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-6">(</span>eq number <span class="org-highlight-numbers-number">0</span><span class="org-rainbow-delimiters-depth-6">)</span>
                            <span class="org-highlight-numbers-number">1</span>
                          <span class="org-rainbow-delimiters-depth-6">(</span>* number <span class="org-rainbow-delimiters-depth-7">(</span>funcall fun fun <span class="org-rainbow-delimiters-depth-8">(</span>1- number<span class="org-rainbow-delimiters-depth-8">)</span><span class="org-rainbow-delimiters-depth-7">)</span><span class="org-rainbow-delimiters-depth-6">)</span><span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-2">(</span>eq <span class="org-rainbow-delimiters-depth-3">(</span>factorial <span class="org-highlight-numbers-number">4</span><span class="org-rainbow-delimiters-depth-3">)</span>
      <span class="org-rainbow-delimiters-depth-3">(</span>funcall meta-factorial meta-factorial <span class="org-highlight-numbers-number">4</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<pre class="example">
t
</pre>

<p>
You might be thinking: "Wait what? did we just did a recursion by calling two
lambdas?" yes we did, it might not look like so here, but if you replace each
<code>meta-fact</code> with the lambda definition, we eliminate references to functions and
are only left with lambda functions but the recursion still works! and we
haven't used a reference to a function from within itself.
</p>

<p>
Let's see now how it looks like. We want a way to transform from proto-factorial
function to meta-factorial because in that way we can get recursion the only
things that we did was to take out the function call and call it on itself.
Let's see if we can define one such a function that takes as a parameter the
proto-factorial and will output the meta-factorial version. Then we have to take
into account how the proto-factorial relates to the factorial and so we end up
with the <a href="http://www.wikiwand.com/en/Fixed-point_combinator#/Derivation_of_the_Y_combinator">YCombinator notation</a> in lambda calculus. In simple terms the
YCombinator looks like this:
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp"><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">defun</span> <span class="org-function-name">YCombinator</span> <span class="org-rainbow-delimiters-depth-2">(</span>fun<span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-2">(</span>funcall
   #'<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">lambda</span> <span class="org-rainbow-delimiters-depth-4">(</span>r<span class="org-rainbow-delimiters-depth-4">)</span>
       <span class="org-rainbow-delimiters-depth-4">(</span>funcall fun <span class="org-rainbow-delimiters-depth-5">(</span>funcall r r<span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span>
   #'<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">lambda</span> <span class="org-rainbow-delimiters-depth-4">(</span>r<span class="org-rainbow-delimiters-depth-4">)</span>
       <span class="org-rainbow-delimiters-depth-4">(</span>funcall fun <span class="org-rainbow-delimiters-depth-5">(</span>funcall r r<span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>
<p>
What this does basically is that it will take a function fun that supposedly depends on 
</p>

<p>
But we have to be careful in Emacs lisp as it does not have lexical binding
unless we ask for it. So it <b>really</b> looks like this:
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp"><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">defun</span> <span class="org-function-name">YCombinator</span> <span class="org-rainbow-delimiters-depth-2">(</span>fun<span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-2">(</span>lexical-let <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-rainbow-delimiters-depth-4">(</span>f fun<span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-3">(</span>funcall #'<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-keyword">lambda</span> <span class="org-rainbow-delimiters-depth-5">(</span>rest<span class="org-rainbow-delimiters-depth-5">)</span>
                 <span class="org-rainbow-delimiters-depth-5">(</span>lexical-let <span class="org-rainbow-delimiters-depth-6">(</span><span class="org-rainbow-delimiters-depth-7">(</span>r rest<span class="org-rainbow-delimiters-depth-7">)</span><span class="org-rainbow-delimiters-depth-6">)</span>
                   <span class="org-rainbow-delimiters-depth-6">(</span>funcall f <span class="org-rainbow-delimiters-depth-7">(</span>funcall r r<span class="org-rainbow-delimiters-depth-7">)</span><span class="org-rainbow-delimiters-depth-6">)</span><span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span>
             #'<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-keyword">lambda</span> <span class="org-rainbow-delimiters-depth-5">(</span>rest<span class="org-rainbow-delimiters-depth-5">)</span>
                 <span class="org-rainbow-delimiters-depth-5">(</span>lexical-let <span class="org-rainbow-delimiters-depth-6">(</span><span class="org-rainbow-delimiters-depth-7">(</span>r rest<span class="org-rainbow-delimiters-depth-7">)</span><span class="org-rainbow-delimiters-depth-6">)</span>
                   <span class="org-rainbow-delimiters-depth-6">(</span>funcall f <span class="org-rainbow-delimiters-depth-7">(</span>funcall r r<span class="org-rainbow-delimiters-depth-7">)</span><span class="org-rainbow-delimiters-depth-6">)</span><span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
Lets try it with our factorial function!
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp"><span class="org-rainbow-delimiters-depth-1">(</span>funcall
 <span class="org-rainbow-delimiters-depth-2">(</span>YCombinator #'<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">lambda</span> <span class="org-rainbow-delimiters-depth-4">(</span>f<span class="org-rainbow-delimiters-depth-4">)</span>
                  <span class="org-rainbow-delimiters-depth-4">(</span>lexical-let <span class="org-rainbow-delimiters-depth-5">(</span><span class="org-rainbow-delimiters-depth-6">(</span>f1 f<span class="org-rainbow-delimiters-depth-6">)</span><span class="org-rainbow-delimiters-depth-5">)</span>
                    #'<span class="org-rainbow-delimiters-depth-5">(</span><span class="org-keyword">lambda</span> <span class="org-rainbow-delimiters-depth-6">(</span>n<span class="org-rainbow-delimiters-depth-6">)</span>
                        <span class="org-rainbow-delimiters-depth-6">(</span><span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-7">(</span>eq n <span class="org-highlight-numbers-number">0</span><span class="org-rainbow-delimiters-depth-7">)</span>
                            <span class="org-highlight-numbers-number">1</span>
                          <span class="org-rainbow-delimiters-depth-7">(</span>* n
                             <span class="org-rainbow-delimiters-depth-8">(</span>funcall f1 <span class="org-rainbow-delimiters-depth-9">(</span>1- n<span class="org-rainbow-delimiters-depth-9">)</span><span class="org-rainbow-delimiters-depth-8">)</span>
                             <span class="org-rainbow-delimiters-depth-7">)</span><span class="org-rainbow-delimiters-depth-6">)</span><span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-highlight-numbers-number">7</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
This should work, but it just goes into an infinite recursive loop, :(.
</p>

<p>
Fortunately enough, I had been warned about this type of behavior due to the
non-laziness from elisp, its eagerness it's not letting the code keep on going
without evaluating stuff that shouldn't be evaluated yet, this doesn't happen in
other languages such as haskell, but in emacs lisp the YCombinator should look a
little bit different, like this:
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp"><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">defun</span> <span class="org-function-name">YCombinator</span> <span class="org-rainbow-delimiters-depth-2">(</span>f<span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-2">(</span>lexical-let <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-rainbow-delimiters-depth-4">(</span>f1 f<span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-3">(</span>funcall
     #'<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-keyword">lambda</span> <span class="org-rainbow-delimiters-depth-5">(</span>x<span class="org-rainbow-delimiters-depth-5">)</span>
         <span class="org-rainbow-delimiters-depth-5">(</span>lexical-let <span class="org-rainbow-delimiters-depth-6">(</span><span class="org-rainbow-delimiters-depth-7">(</span>x1 x<span class="org-rainbow-delimiters-depth-7">)</span><span class="org-rainbow-delimiters-depth-6">)</span>
           <span class="org-rainbow-delimiters-depth-6">(</span>funcall f1 #'<span class="org-rainbow-delimiters-depth-7">(</span><span class="org-keyword">lambda</span> <span class="org-rainbow-delimiters-depth-8">(</span>y<span class="org-rainbow-delimiters-depth-8">)</span>
                           <span class="org-rainbow-delimiters-depth-8">(</span>lexical-let <span class="org-rainbow-delimiters-depth-9">(</span><span class="org-rainbow-delimiters-depth-1">(</span>y1 y<span class="org-rainbow-delimiters-depth-1">)</span><span class="org-rainbow-delimiters-depth-9">)</span>
                             <span class="org-rainbow-delimiters-depth-9">(</span>funcall <span class="org-rainbow-delimiters-depth-1">(</span>funcall x1 x1<span class="org-rainbow-delimiters-depth-1">)</span> y<span class="org-rainbow-delimiters-depth-9">)</span><span class="org-rainbow-delimiters-depth-8">)</span>
                           <span class="org-rainbow-delimiters-depth-7">)</span><span class="org-rainbow-delimiters-depth-6">)</span><span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span>
     #'<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-keyword">lambda</span> <span class="org-rainbow-delimiters-depth-5">(</span>x<span class="org-rainbow-delimiters-depth-5">)</span>
         <span class="org-rainbow-delimiters-depth-5">(</span>lexical-let <span class="org-rainbow-delimiters-depth-6">(</span><span class="org-rainbow-delimiters-depth-7">(</span>x1 x<span class="org-rainbow-delimiters-depth-7">)</span><span class="org-rainbow-delimiters-depth-6">)</span>
           <span class="org-rainbow-delimiters-depth-6">(</span>funcall f1 #'<span class="org-rainbow-delimiters-depth-7">(</span><span class="org-keyword">lambda</span> <span class="org-rainbow-delimiters-depth-8">(</span>y<span class="org-rainbow-delimiters-depth-8">)</span>
                           <span class="org-rainbow-delimiters-depth-8">(</span>lexical-let <span class="org-rainbow-delimiters-depth-9">(</span><span class="org-rainbow-delimiters-depth-1">(</span>y1 y<span class="org-rainbow-delimiters-depth-1">)</span><span class="org-rainbow-delimiters-depth-9">)</span>
                             <span class="org-rainbow-delimiters-depth-9">(</span>funcall <span class="org-rainbow-delimiters-depth-1">(</span>funcall x1 x1<span class="org-rainbow-delimiters-depth-1">)</span> y<span class="org-rainbow-delimiters-depth-9">)</span><span class="org-rainbow-delimiters-depth-8">)</span><span class="org-rainbow-delimiters-depth-7">)</span><span class="org-rainbow-delimiters-depth-6">)</span><span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>


<p>
There! now we have a working YCombinator :) lets try it
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp"><span class="org-rainbow-delimiters-depth-1">(</span>funcall
 <span class="org-rainbow-delimiters-depth-2">(</span>YCombinator
  #'<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">lambda</span> <span class="org-rainbow-delimiters-depth-4">(</span>f<span class="org-rainbow-delimiters-depth-4">)</span>
      <span class="org-rainbow-delimiters-depth-4">(</span>lexical-let <span class="org-rainbow-delimiters-depth-5">(</span><span class="org-rainbow-delimiters-depth-6">(</span>f1 f<span class="org-rainbow-delimiters-depth-6">)</span><span class="org-rainbow-delimiters-depth-5">)</span>
        #'<span class="org-rainbow-delimiters-depth-5">(</span><span class="org-keyword">lambda</span> <span class="org-rainbow-delimiters-depth-6">(</span>n<span class="org-rainbow-delimiters-depth-6">)</span>
            <span class="org-rainbow-delimiters-depth-6">(</span><span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-7">(</span>eq n <span class="org-highlight-numbers-number">0</span><span class="org-rainbow-delimiters-depth-7">)</span>
                <span class="org-highlight-numbers-number">1</span>
              <span class="org-rainbow-delimiters-depth-7">(</span>* n
                 <span class="org-rainbow-delimiters-depth-8">(</span>funcall f1 <span class="org-rainbow-delimiters-depth-9">(</span>1- n<span class="org-rainbow-delimiters-depth-9">)</span><span class="org-rainbow-delimiters-depth-8">)</span>
                 <span class="org-rainbow-delimiters-depth-7">)</span><span class="org-rainbow-delimiters-depth-6">)</span><span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span>
 <span class="org-highlight-numbers-number">8</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<pre class="example">
40320
</pre>

<p>
There we go! :) this is the kind of stuff one learns in the Recurse Center. I
hope you liked it, I've seen implementations done in javascript and even python,
but not so many in emacs lisp. I hope it was clear enough to understand.
</p>

    </article>

<footer class="site-footer">
    <div class="back-to-top">
        <a href="#">back to top</a>
        <a id="show-comments"  onclick="loadDisqus()"> show comments</a>
    </div>
    <script src="/media/js/main.js"></script>
    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
        <script>
         (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
             (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                                  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
         })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

         ga('create', 'UA-40864129-3', 'auto');
         ga('send', 'pageview');
        </script>
            <div id="disqus_thread"></div>
            <script type="text/javascript">
             /* * * CONFIGURATION VARIABLES * * */
             var disqus_identifier = "/blog/2015/10/13/y-combinator-in-emacs-lisp";
             var disqus_url = "http://cestdiego.github.io/blog/2015/10/13/y-combinator-in-emacs-lisp";
             var disqus_shortname = 'cestdiego';

             /* * * DON'T EDIT BELOW THIS LINE * * */
             var ds_loaded = false;
             var le_top = document.getElementById("disqus_thread").offsetTop;

             function loadDisqus(){
                 ds_loaded = true;
                 (function() {
                     var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                     dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                     (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
                 })();
                 document.getElementById("show-comments").style.visibility = "hidden"
             }

             var reload_disqus = function(){
                 DISQUS.reset({
                     reload: true,
                     config: function () {
                         this.page.identifier = cestdiego;
                     }
                 });
             }
            </script>
            <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
</footer>

    </div>
  </body>
</html>
