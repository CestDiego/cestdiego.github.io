<!DOCTYPE html>
<html lang="en-us">
  <head>
    <title>Y Combinator in Emacs Lisp - Diego Berrocal</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="author" content="Diego Berrocal">
    <meta name="description" content="Or how to implement the YCombinator in Emacs Lisp">
    <meta name="keywords" content="ycombinator, lambda, emacs, elisp">
    <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Fira+Sans:400,700,400italic,700italic|Lora:400,700|Source+Code+Pro:400,700">
    <link rel="stylesheet" href="/media/css/normalize.css">
    <link rel="stylesheet" href="/media/css/dark.css" id="darkTheme">
    <link rel="stylesheet" href="/media/css/light.css" id="lightTheme">
    <link href="http://cestdiego.github.io/atom.xml" type="application/atom+xml" rel="alternate" title="Diego Berrocal" />
    <script>
     var lightTheme = document.querySelector("#lightTheme");
     var darkTheme = document.querySelector("#darkTheme");

     var toggleTheme = function () {
         var isDefaultDisabled = lightTheme.disabled;
         darkTheme.disabled = isDefaultDisabled;
         lightTheme.disabled = !isDefaultDisabled;

         var switchLights = document.querySelector(".switch-lights");
         switchLights.textContent = "lights " + (isDefaultDisabled ? "off" : "on");

         return !isDefaultDisabled;
     };

     if (localStorage.darkTheme === "1") {
         toggleTheme();
     }
    </script>
    <link rel="stylesheet" href="/media/css/main.css">
    <noscript>
        <style>
         .toggle-colors{
             display: none;
         }
        </style>
    </noscript>
  </head>

  <body>
    <div id="wrapper">
    <nav class="site-nav">
      <ul class="links">
        <li><a href="/">Diego Berrocal</a></li>
         <li><a href="/about/">about</a></li>
        <li><a href="/blog/">blog</a></li>
        <li><a href="/tags/">tags</a></li>
        <li><a href="/atom.xml">atom</a></li>
        <li><button class="switch-lights">lights off</button></li>
      </ul>
    </nav>

    <article class="post">
      <header>
          <h1 class="post-title">Y Combinator in Emacs Lisp</h1>
          <time class="post-date">Oct 12, 2015</time>
      </header>
      <p>
I talked today with Prabhakar Ragde, who is a resident at the Recurse Center
until Oct15, and I was enlightened by lambda calculus as we figured out how to
deduce the Y Combinator that is used a lot to make recursive functions.
</p>

<p>
Here I plan to post the implementation and derivation of the Y Combinator in
Emacs Lisp. 
</p>

<p>
:DISCLAIMER_BEGIN: 
</p>

<p>
You will need to have lexical binding enabled for most of the examples to work,
it is a buffer-local variable so make sure you paste everything on the same
buffer.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp"><span class="org-rainbow-delimiters-depth-1">(</span>setq lexical-binding t<span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
:DISCLAIMER_END:
</p>

<p>
We'll take <code>factorial</code> as it's good example of a recursive function
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp"><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">defun</span> <span class="org-function-name">factorial</span> <span class="org-rainbow-delimiters-depth-2">(</span>number<span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-3">(</span>eq number <span class="org-highlight-numbers-number">0</span><span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-highlight-numbers-number">1</span>
    <span class="org-rainbow-delimiters-depth-3">(</span>* number <span class="org-rainbow-delimiters-depth-4">(</span>funcall #'factorial <span class="org-rainbow-delimiters-depth-5">(</span>1- number<span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-rainbow-delimiters-depth-1">(</span>factorial <span class="org-highlight-numbers-number">5</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">120</span>
<span class="org-rainbow-delimiters-depth-1">(</span>factorial <span class="org-highlight-numbers-number">4</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-comment-delimiter">;; </span><span class="org-comment">24</span>
</pre>
</div>

<p>
The recursion looks trivial right? Now lets try to implement it without
referencing the name of the function, should be easy as well.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp"><span class="org-comment-delimiter">;; </span><span class="org-comment">factorial</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">lambda</span> <span class="org-rainbow-delimiters-depth-2">(</span>number<span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-3">(</span>eq number <span class="org-highlight-numbers-number">0</span><span class="org-rainbow-delimiters-depth-3">)</span>
      <span class="org-highlight-numbers-number">1</span>
    <span class="org-rainbow-delimiters-depth-3">(</span>* number <span class="org-rainbow-delimiters-depth-4">(</span>funcall fact? <span class="org-rainbow-delimiters-depth-5">(</span>1- number<span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
We find that we cannot reference back to the same lambda function as we don't
have a name for it, that's why we use <b>fact?</b> we'll have to figure out what to
put in there. Lets say that we have another function that <b>looks</b> like <code>factorial</code>.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp"><span class="org-comment-delimiter">;; </span><span class="org-comment">proto-factorial</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">lambda</span> <span class="org-rainbow-delimiters-depth-2">(</span>fun<span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">lambda</span> <span class="org-rainbow-delimiters-depth-3">(</span>number<span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-4">(</span>eq number <span class="org-highlight-numbers-number">0</span><span class="org-rainbow-delimiters-depth-4">)</span>
        <span class="org-highlight-numbers-number">1</span>
      <span class="org-rainbow-delimiters-depth-4">(</span>* number <span class="org-rainbow-delimiters-depth-5">(</span>funcall fun <span class="org-rainbow-delimiters-depth-6">(</span>1- number<span class="org-rainbow-delimiters-depth-6">)</span><span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
This is great! now we have a function that can take another function and that
returns a function that looks like <code>factorial</code>. There is one little detail
though, the function that <code>proto-factorial</code> accepts only takes a number, so we
could say that.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp"><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">let</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-rainbow-delimiters-depth-3">(</span>proto-factorial <span class="org-rainbow-delimiters-depth-4">(</span><span class="org-keyword">lambda</span> <span class="org-rainbow-delimiters-depth-5">(</span>fun<span class="org-rainbow-delimiters-depth-5">)</span>
                         <span class="org-rainbow-delimiters-depth-5">(</span><span class="org-keyword">lambda</span> <span class="org-rainbow-delimiters-depth-6">(</span>number<span class="org-rainbow-delimiters-depth-6">)</span>
                           <span class="org-rainbow-delimiters-depth-6">(</span><span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-7">(</span>eq number <span class="org-highlight-numbers-number">0</span><span class="org-rainbow-delimiters-depth-7">)</span>
                               <span class="org-highlight-numbers-number">1</span>
                             <span class="org-rainbow-delimiters-depth-7">(</span>* number <span class="org-rainbow-delimiters-depth-8">(</span>funcall fun <span class="org-rainbow-delimiters-depth-9">(</span>1- number<span class="org-rainbow-delimiters-depth-9">)</span><span class="org-rainbow-delimiters-depth-8">)</span><span class="org-rainbow-delimiters-depth-7">)</span><span class="org-rainbow-delimiters-depth-6">)</span><span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-2">(</span>eq <span class="org-rainbow-delimiters-depth-3">(</span>funcall 'factorial <span class="org-highlight-numbers-number">4</span><span class="org-rainbow-delimiters-depth-3">)</span>
      <span class="org-rainbow-delimiters-depth-3">(</span>funcall <span class="org-rainbow-delimiters-depth-4">(</span>funcall proto-factorial 'factorial<span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-highlight-numbers-number">4</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>


<p>
This holds true but it's not what we want. We show that applying
<code>proto-factorial</code> to <code>factorial</code> gives us back <code>factorial</code> which is cool, but we
need to not use <code>factorial</code> at all, let's see if using <code>proto-factorial</code> on itself
might work
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp"><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">let</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-rainbow-delimiters-depth-3">(</span>proto-factorial <span class="org-rainbow-delimiters-depth-4">(</span><span class="org-keyword">lambda</span> <span class="org-rainbow-delimiters-depth-5">(</span>fun<span class="org-rainbow-delimiters-depth-5">)</span>
                         <span class="org-rainbow-delimiters-depth-5">(</span><span class="org-keyword">lambda</span> <span class="org-rainbow-delimiters-depth-6">(</span>number<span class="org-rainbow-delimiters-depth-6">)</span>
                           <span class="org-rainbow-delimiters-depth-6">(</span><span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-7">(</span>eq number <span class="org-highlight-numbers-number">0</span><span class="org-rainbow-delimiters-depth-7">)</span>
                               <span class="org-highlight-numbers-number">1</span>
                             <span class="org-rainbow-delimiters-depth-7">(</span>* number <span class="org-rainbow-delimiters-depth-8">(</span>funcall fun <span class="org-rainbow-delimiters-depth-9">(</span>1- number<span class="org-rainbow-delimiters-depth-9">)</span><span class="org-rainbow-delimiters-depth-8">)</span><span class="org-rainbow-delimiters-depth-7">)</span><span class="org-rainbow-delimiters-depth-6">)</span><span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-2">(</span>funcall <span class="org-rainbow-delimiters-depth-3">(</span>funcall proto-factorial proto-factorial<span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-highlight-numbers-number">4</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
It didn't T_T. What this tells us is that we have not provided enough arguments,
and that's true, because proto-factorial, the function we send, takes a function
and and returns a function that takes number, and the outer <code>funcall</code> just takes
another number but no function. this is tricky, but we can have a way of doing
it, let's call the function on itself as an argument before passing another
number!
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp"><span class="org-comment-delimiter">;; </span><span class="org-comment">meta-factorial</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">lambda</span> <span class="org-rainbow-delimiters-depth-2">(</span>fun<span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">lambda</span> <span class="org-rainbow-delimiters-depth-3">(</span>number<span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-4">(</span>eq number <span class="org-highlight-numbers-number">0</span><span class="org-rainbow-delimiters-depth-4">)</span>
        <span class="org-highlight-numbers-number">1</span>
      <span class="org-rainbow-delimiters-depth-4">(</span>* number <span class="org-rainbow-delimiters-depth-5">(</span>funcall <span class="org-rainbow-delimiters-depth-6">(</span>funcall fun fun<span class="org-rainbow-delimiters-depth-6">)</span> <span class="org-rainbow-delimiters-depth-6">(</span>1- number<span class="org-rainbow-delimiters-depth-6">)</span><span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
This looks more promising! meta-factorial takes a function and returns a
function that depends on a number, but in this inner number-dependent function
instead of applying <code>fun</code> to <code>(1- number)</code> we apply the function to itself, and
then apply that result to <code>(1- number)</code>, this way we got what we wanted, a
recursive function!. But still looks ugly, lets arrange it in a better way
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp"><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">let</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-rainbow-delimiters-depth-3">(</span>meta-factorial <span class="org-rainbow-delimiters-depth-4">(</span><span class="org-keyword">lambda</span> <span class="org-rainbow-delimiters-depth-5">(</span>fun<span class="org-rainbow-delimiters-depth-5">)</span>
                        <span class="org-rainbow-delimiters-depth-5">(</span><span class="org-keyword">lambda</span> <span class="org-rainbow-delimiters-depth-6">(</span>number<span class="org-rainbow-delimiters-depth-6">)</span>
                          <span class="org-rainbow-delimiters-depth-6">(</span><span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-7">(</span>eq number <span class="org-highlight-numbers-number">0</span><span class="org-rainbow-delimiters-depth-7">)</span>
                              <span class="org-highlight-numbers-number">1</span>
                            <span class="org-rainbow-delimiters-depth-7">(</span>* number <span class="org-rainbow-delimiters-depth-8">(</span>funcall <span class="org-rainbow-delimiters-depth-9">(</span>funcall fun fun<span class="org-rainbow-delimiters-depth-9">)</span> <span class="org-rainbow-delimiters-depth-9">(</span>1- number<span class="org-rainbow-delimiters-depth-9">)</span><span class="org-rainbow-delimiters-depth-8">)</span><span class="org-rainbow-delimiters-depth-7">)</span><span class="org-rainbow-delimiters-depth-6">)</span><span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-2">(</span>eq <span class="org-rainbow-delimiters-depth-3">(</span>funcall 'factorial <span class="org-highlight-numbers-number">4</span><span class="org-rainbow-delimiters-depth-3">)</span>
      <span class="org-rainbow-delimiters-depth-3">(</span>funcall <span class="org-rainbow-delimiters-depth-4">(</span>funcall meta-factorial meta-factorial<span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-highlight-numbers-number">4</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>


<p>
You might be thinking: "Wait what? did we just did a recursion by calling two
lambdas?" yes we did, it might not look like so here, but if you replace each
<code>meta-fact</code> with the lambda definition, we eliminate references to functions and
are only left with lambda functions but the recursion still works! and we
haven't used a reference to a function from within itself. If you don't believe
me, then this is the ugly version:
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp"><span class="org-rainbow-delimiters-depth-1">(</span>funcall <span class="org-rainbow-delimiters-depth-2">(</span>funcall #'<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">lambda</span> <span class="org-rainbow-delimiters-depth-4">(</span>fun<span class="org-rainbow-delimiters-depth-4">)</span>
                      <span class="org-rainbow-delimiters-depth-4">(</span><span class="org-keyword">lambda</span> <span class="org-rainbow-delimiters-depth-5">(</span>number<span class="org-rainbow-delimiters-depth-5">)</span>
                        <span class="org-rainbow-delimiters-depth-5">(</span><span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-6">(</span>eq number <span class="org-highlight-numbers-number">0</span><span class="org-rainbow-delimiters-depth-6">)</span>
                            <span class="org-highlight-numbers-number">1</span>
                          <span class="org-rainbow-delimiters-depth-6">(</span>* number <span class="org-rainbow-delimiters-depth-7">(</span>funcall <span class="org-rainbow-delimiters-depth-8">(</span>funcall fun fun<span class="org-rainbow-delimiters-depth-8">)</span> <span class="org-rainbow-delimiters-depth-8">(</span>1- number<span class="org-rainbow-delimiters-depth-8">)</span><span class="org-rainbow-delimiters-depth-7">)</span><span class="org-rainbow-delimiters-depth-6">)</span><span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span>
                  #'<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">lambda</span> <span class="org-rainbow-delimiters-depth-4">(</span>fun<span class="org-rainbow-delimiters-depth-4">)</span>
                      <span class="org-rainbow-delimiters-depth-4">(</span><span class="org-keyword">lambda</span> <span class="org-rainbow-delimiters-depth-5">(</span>number<span class="org-rainbow-delimiters-depth-5">)</span>
                        <span class="org-rainbow-delimiters-depth-5">(</span><span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-6">(</span>eq number <span class="org-highlight-numbers-number">0</span><span class="org-rainbow-delimiters-depth-6">)</span>
                            <span class="org-highlight-numbers-number">1</span>
                          <span class="org-rainbow-delimiters-depth-6">(</span>* number <span class="org-rainbow-delimiters-depth-7">(</span>funcall <span class="org-rainbow-delimiters-depth-8">(</span>funcall fun fun<span class="org-rainbow-delimiters-depth-8">)</span> <span class="org-rainbow-delimiters-depth-8">(</span>1- number<span class="org-rainbow-delimiters-depth-8">)</span><span class="org-rainbow-delimiters-depth-7">)</span><span class="org-rainbow-delimiters-depth-6">)</span><span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span>
                  <span class="org-rainbow-delimiters-depth-2">)</span>
         <span class="org-highlight-numbers-number">4</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
This still returns what we wanted which is <code>4!</code>. So what we have now is that
<code>meta-factorial</code> evaluated on itself returns a function that takes a number and
that function is equivalent to <code>factorial</code>.
</p>

<p>
We want a way to transform from proto-factorial function to <code>factorial</code> because in
that way we can get recursion, out of a simpler function the only things that we
did was to take out the function call and call it on itself. 
</p>

<p>
Let's see if we can define one such a function that takes as a parameter the
proto-factorial and will output the meta-factorial version because in that case
we would only need to apply that function twice and we would get our so desired
factorial.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp"><span class="org-comment-delimiter">;; </span><span class="org-comment">meta-factorial</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">lambda</span> <span class="org-rainbow-delimiters-depth-2">(</span>fun<span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-2">(</span>funcall
   #'<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">lambda</span> <span class="org-rainbow-delimiters-depth-4">(</span>fun2<span class="org-rainbow-delimiters-depth-4">)</span>
       <span class="org-rainbow-delimiters-depth-4">(</span><span class="org-keyword">lambda</span> <span class="org-rainbow-delimiters-depth-5">(</span>number<span class="org-rainbow-delimiters-depth-5">)</span>
         <span class="org-rainbow-delimiters-depth-5">(</span><span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-6">(</span>eq number <span class="org-highlight-numbers-number">0</span><span class="org-rainbow-delimiters-depth-6">)</span>
             <span class="org-highlight-numbers-number">1</span>
           <span class="org-rainbow-delimiters-depth-6">(</span>* number <span class="org-rainbow-delimiters-depth-7">(</span>funcall fun2 <span class="org-rainbow-delimiters-depth-8">(</span>1- number<span class="org-rainbow-delimiters-depth-8">)</span><span class="org-rainbow-delimiters-depth-7">)</span><span class="org-rainbow-delimiters-depth-6">)</span><span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span>
   <span class="org-rainbow-delimiters-depth-3">(</span>funcall fun fun<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
What we just did was to wrap the inner number-dependent function so that the
<code>(funcall fun fun)</code> could be abstracted. This is called composing functions,
kinda like <code>g(x^2)</code> could be written as <code>g(f(x))</code> where <code>f(x) = x^2</code> and we find
that this inner thing is actually, <code>proto-factorial</code> !! This is great!, now we
can write meta <code>factorial</code> in terms of proto <code>factorial</code>. We just needed to wrap the
fun2 into a call to itself.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp"><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">let</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-rainbow-delimiters-depth-3">(</span>meta-factorial <span class="org-rainbow-delimiters-depth-4">(</span><span class="org-keyword">lambda</span> <span class="org-rainbow-delimiters-depth-5">(</span>fun<span class="org-rainbow-delimiters-depth-5">)</span>
                        <span class="org-rainbow-delimiters-depth-5">(</span><span class="org-keyword">lambda</span> <span class="org-rainbow-delimiters-depth-6">(</span>number<span class="org-rainbow-delimiters-depth-6">)</span>
                          <span class="org-rainbow-delimiters-depth-6">(</span><span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-7">(</span>eq number <span class="org-highlight-numbers-number">0</span><span class="org-rainbow-delimiters-depth-7">)</span>
                              <span class="org-highlight-numbers-number">1</span>
                            <span class="org-rainbow-delimiters-depth-7">(</span>* number <span class="org-rainbow-delimiters-depth-8">(</span>funcall <span class="org-rainbow-delimiters-depth-9">(</span>funcall fun fun<span class="org-rainbow-delimiters-depth-9">)</span> <span class="org-rainbow-delimiters-depth-9">(</span>1- number<span class="org-rainbow-delimiters-depth-9">)</span><span class="org-rainbow-delimiters-depth-8">)</span><span class="org-rainbow-delimiters-depth-7">)</span><span class="org-rainbow-delimiters-depth-6">)</span><span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span>
      <span class="org-rainbow-delimiters-depth-3">(</span>proto-factorial <span class="org-rainbow-delimiters-depth-4">(</span><span class="org-keyword">lambda</span> <span class="org-rainbow-delimiters-depth-5">(</span>fun<span class="org-rainbow-delimiters-depth-5">)</span>
                         <span class="org-rainbow-delimiters-depth-5">(</span><span class="org-keyword">lambda</span> <span class="org-rainbow-delimiters-depth-6">(</span>number<span class="org-rainbow-delimiters-depth-6">)</span>
                           <span class="org-rainbow-delimiters-depth-6">(</span><span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-7">(</span>eq number <span class="org-highlight-numbers-number">0</span><span class="org-rainbow-delimiters-depth-7">)</span>
                               <span class="org-highlight-numbers-number">1</span>
                             <span class="org-rainbow-delimiters-depth-7">(</span>* number <span class="org-rainbow-delimiters-depth-8">(</span>funcall fun <span class="org-rainbow-delimiters-depth-9">(</span>1- number<span class="org-rainbow-delimiters-depth-9">)</span><span class="org-rainbow-delimiters-depth-8">)</span><span class="org-rainbow-delimiters-depth-7">)</span><span class="org-rainbow-delimiters-depth-6">)</span><span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-2">(</span>eq <span class="org-rainbow-delimiters-depth-3">(</span>funcall 'factorial <span class="org-highlight-numbers-number">4</span><span class="org-rainbow-delimiters-depth-3">)</span>
      <span class="org-rainbow-delimiters-depth-3">(</span>funcall <span class="org-rainbow-delimiters-depth-4">(</span>funcall #'<span class="org-rainbow-delimiters-depth-5">(</span><span class="org-keyword">lambda</span> <span class="org-rainbow-delimiters-depth-6">(</span>r<span class="org-rainbow-delimiters-depth-6">)</span>
                            <span class="org-rainbow-delimiters-depth-6">(</span>funcall proto-factorial <span class="org-rainbow-delimiters-depth-7">(</span>funcall r r<span class="org-rainbow-delimiters-depth-7">)</span><span class="org-rainbow-delimiters-depth-6">)</span><span class="org-rainbow-delimiters-depth-5">)</span>
                        #'<span class="org-rainbow-delimiters-depth-5">(</span><span class="org-keyword">lambda</span> <span class="org-rainbow-delimiters-depth-6">(</span>r<span class="org-rainbow-delimiters-depth-6">)</span>
                            <span class="org-rainbow-delimiters-depth-6">(</span>funcall proto-factorial <span class="org-rainbow-delimiters-depth-7">(</span>funcall r r<span class="org-rainbow-delimiters-depth-7">)</span><span class="org-rainbow-delimiters-depth-6">)</span><span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span>
               <span class="org-highlight-numbers-number">4</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
This is basically what we've been going for so much, if we could only make one
more abstraction so that in case of proto-factorial we could pass any function
wouldn't it be nice? well it <b>is</b> possible and it has a name! it's called the Y
combinator, and it looks like this:
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp"><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">defun</span> <span class="org-function-name">YCombinator</span> <span class="org-rainbow-delimiters-depth-2">(</span>fun<span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">(</span>funcall #'<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">lambda</span> <span class="org-rainbow-delimiters-depth-4">(</span>r<span class="org-rainbow-delimiters-depth-4">)</span>
                   <span class="org-rainbow-delimiters-depth-4">(</span>funcall fun <span class="org-rainbow-delimiters-depth-5">(</span>funcall r r<span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span>
             #'<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">lambda</span> <span class="org-rainbow-delimiters-depth-4">(</span>r<span class="org-rainbow-delimiters-depth-4">)</span>
                   <span class="org-rainbow-delimiters-depth-4">(</span>funcall fun <span class="org-rainbow-delimiters-depth-5">(</span>funcall r r<span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
Lets try it with our <code>factorial</code> function!
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp"><span class="org-rainbow-delimiters-depth-1">(</span>funcall
 <span class="org-rainbow-delimiters-depth-2">(</span>YCombinator #'<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">lambda</span> <span class="org-rainbow-delimiters-depth-4">(</span>f<span class="org-rainbow-delimiters-depth-4">)</span>
                  #'<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-keyword">lambda</span> <span class="org-rainbow-delimiters-depth-5">(</span>n<span class="org-rainbow-delimiters-depth-5">)</span>
                      <span class="org-rainbow-delimiters-depth-5">(</span><span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-6">(</span>eq n <span class="org-highlight-numbers-number">0</span><span class="org-rainbow-delimiters-depth-6">)</span>
                          <span class="org-highlight-numbers-number">1</span>
                        <span class="org-rainbow-delimiters-depth-6">(</span>* n
                           <span class="org-rainbow-delimiters-depth-7">(</span>funcall f <span class="org-rainbow-delimiters-depth-8">(</span>1- n<span class="org-rainbow-delimiters-depth-8">)</span><span class="org-rainbow-delimiters-depth-7">)</span>
                           <span class="org-rainbow-delimiters-depth-6">)</span><span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-highlight-numbers-number">5</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
This should work, but it just goes into an infinite recursive loop, :(.
</p>

<p>
Fortunately enough, I had been warned about this type of behavior due to the
non-laziness from elisp, its eagerness it's not letting the code keep on going
without evaluating stuff that shouldn't be evaluated yet, this doesn't happen in
other languages such as haskell, but in emacs lisp the YCombinator should look a
little bit different, like this:
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp"><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">defun</span> <span class="org-function-name">YCombinator</span> <span class="org-rainbow-delimiters-depth-2">(</span>f<span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-2">(</span>funcall #'<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">lambda</span> <span class="org-rainbow-delimiters-depth-4">(</span>x<span class="org-rainbow-delimiters-depth-4">)</span>
               <span class="org-rainbow-delimiters-depth-4">(</span>funcall f #'<span class="org-rainbow-delimiters-depth-5">(</span><span class="org-keyword">lambda</span> <span class="org-rainbow-delimiters-depth-6">(</span>y<span class="org-rainbow-delimiters-depth-6">)</span>
                              <span class="org-rainbow-delimiters-depth-6">(</span>funcall <span class="org-rainbow-delimiters-depth-7">(</span>funcall x x<span class="org-rainbow-delimiters-depth-7">)</span> y<span class="org-rainbow-delimiters-depth-6">)</span><span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span>
           #'<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">lambda</span> <span class="org-rainbow-delimiters-depth-4">(</span>x<span class="org-rainbow-delimiters-depth-4">)</span>
               <span class="org-rainbow-delimiters-depth-4">(</span>funcall f #'<span class="org-rainbow-delimiters-depth-5">(</span><span class="org-keyword">lambda</span> <span class="org-rainbow-delimiters-depth-6">(</span>y<span class="org-rainbow-delimiters-depth-6">)</span>
                              <span class="org-rainbow-delimiters-depth-6">(</span>funcall <span class="org-rainbow-delimiters-depth-7">(</span>funcall x x<span class="org-rainbow-delimiters-depth-7">)</span> y<span class="org-rainbow-delimiters-depth-6">)</span><span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>


<p>
There! now we have a working YCombinator that doesn't go into an infinite loop
:) lets try it
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp"><span class="org-rainbow-delimiters-depth-1">(</span>funcall
 <span class="org-rainbow-delimiters-depth-2">(</span>YCombinator
  #'<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">lambda</span> <span class="org-rainbow-delimiters-depth-4">(</span>f<span class="org-rainbow-delimiters-depth-4">)</span>
      #'<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-keyword">lambda</span> <span class="org-rainbow-delimiters-depth-5">(</span>n<span class="org-rainbow-delimiters-depth-5">)</span>
          <span class="org-rainbow-delimiters-depth-5">(</span><span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-6">(</span>eq n <span class="org-highlight-numbers-number">0</span><span class="org-rainbow-delimiters-depth-6">)</span>
              <span class="org-highlight-numbers-number">1</span>
            <span class="org-rainbow-delimiters-depth-6">(</span>* n
               <span class="org-rainbow-delimiters-depth-7">(</span>funcall f <span class="org-rainbow-delimiters-depth-8">(</span>1- n<span class="org-rainbow-delimiters-depth-8">)</span><span class="org-rainbow-delimiters-depth-7">)</span><span class="org-rainbow-delimiters-depth-6">)</span><span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span>
 <span class="org-highlight-numbers-number">8</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
There we go! :) this is the kind of stuff one learns in the Recurse Center. I
hope you liked it, I've seen implementations done in javascript and even python,
but not one in Emacs Lisp for the <code>factorial</code> function. There was one that got it
right for the <a href="https://gist.github.com/yukihr/df9c3fcf9002cc3b3d03">Fibonacci sequence</a> but when I tried it on the <code>factorial</code> it went
into the infinite loop,
</p>

    </article>

<footer class="site-footer">
    <div class="back-to-top">
        <a href="#">back to top</a>
        <a id="show-comments"  onclick="loadDisqus()"> show comments</a>
    </div>
    <script src="/media/js/main.js"></script>
    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
        <script>
         (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
             (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                                  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
         })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

         ga('create', 'UA-40864129-3', 'auto');
         ga('send', 'pageview');
        </script>
            <div id="disqus_thread"></div>
            <script type="text/javascript">
             /* * * CONFIGURATION VARIABLES * * */
             var disqus_identifier = "/blog/2015/10/13/y-combinator-in-emacs-lisp";
             var disqus_url = "http://cestdiego.github.io/blog/2015/10/13/y-combinator-in-emacs-lisp";
             var disqus_shortname = 'cestdiego';

             /* * * DON'T EDIT BELOW THIS LINE * * */
             var ds_loaded = false;
             var le_top = document.getElementById("disqus_thread").offsetTop;

             function loadDisqus(){
                 ds_loaded = true;
                 (function() {
                     var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                     dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                     (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
                 })();
                 document.getElementById("show-comments").style.visibility = "hidden"
             }

             var reload_disqus = function(){
                 DISQUS.reset({
                     reload: true,
                     config: function () {
                         this.page.identifier = cestdiego;
                     }
                 });
             }
            </script>
            <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
</footer>

    </div>
  </body>
</html>
